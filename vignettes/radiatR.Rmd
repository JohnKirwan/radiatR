---
title: "radiatR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{radiatR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

### Set up

```{r, include  =  FALSE}
knitr::opts_chunk$set(
  collapse  =  TRUE,
  comment  =  "#>" )
```

```{r setup}
library('dplyr')
library('ggplot2')
library('purrr')
library('ggnewscale')
library('ggforce')
library('ggrepel')
library('ggnewscale')
library('radiatR')
```

The package radiatR plots tracks in circular space.

Track data can be loaded using import_tracks(). Here we load example data.

```{r}
path1 <- "../tracking"
path2 <- "C:\\Users\\jkirwan\\source\\repos\\P_lividus_adult_vision\\tracking"

track_dir   <- normalizePath(path1)

track_list <- import_tracks(track_dir,
  landmark_suffix  =  '_point01.txt', track_suffix  =  '_point02.txt')
tail(track_list)
```

The data frame contains the names of the three videos. We need to import a table describing these videos.

```{r}
#file_info <- import_info(normalizePath('../data/headings.csv')) #,'stimulus','degrees'
#file_info <- headings
#head(file_info)
```

The data frame contains a row for each trial. The function also checks if there is a mismatch between this data table and the track files.

```{r}
trial_details     <- read.csv('../data/trials_list.csv')
trial_details$obstacle[trial_details$obstacle ==  "none"]    <- "unobst"
trial_details$obstacle[trial_details$obstacle == "marbles"] <- "obst"
trial_details |> 
  tidyr::unite("cond", c(type,arc,obstacle), remove = FALSE, sep = "_") -> trial_details
tail(trial_details)
```

```{r}
#> file_tbl, track_list_df,track_dir
file_tbl <- load_tracks(track_list, trial_details, track_dir)
tail(file_tbl)
```

Add part above to put trial, cond, type, arc, obstacle into file_tbl and therefore to trackz_tbl and trialz.

```{r}
#> which track rows shares vid name with df
file_tbl$arc  <- rep(0,dim(file_tbl)[1])
file_tbl$type <- as.character(rep("",dim(file_tbl)[1]))
file_tbl$obstacle <- as.character(rep("",dim(file_tbl)[1]))
file_tbl$id       <- as.character(rep("",dim(file_tbl)[1]))
tail(file_tbl)
```

```{r}
i = 1
while(i <=  dim(trial_details)[1]){
 file_tbl$arc [which(file_tbl$basename == trial_details$file[i])] <- trial_details$arc[i]
 file_tbl$type[which(file_tbl$basename == trial_details$file[i])] <- trial_details$type[i]
 file_tbl$obstacle[which(file_tbl$basename == trial_details$file[i])] <- trial_details$obstacle[i]
 file_tbl$id[which(file_tbl$basename == trial_details$file[i])] <- trial_details$id[i]
 i = i + 1      
 }

file_tbl |> tidyr::unite("cond",c(type,arc,obstacle),remove = FALSE, sep = "_")
```

Are there any (predicted) track names not represented in the file list? i.e. landmark files without a matching track file

```{r}
if (any(!file_tbl$track %in% list.files((track_dir), recursive = TRUE))) {
  stop(print(paste0("The following track file is missing:",
    file_tbl$track[which(!file_tbl$track %in% list.files(
      (track_dir),recursive = TRUE))])))  }
```

```{r}
#> are any track files in the file list without a match in the landmark files?
if (any(!list.files((track_dir),recursive = TRUE)[grep('*point02.txt$',
    list.files((track_dir),recursive = TRUE))] %in% file_tbl$track)) {
  stop(print(paste0("The following track file lacks a counterpart:",
    list.files((track_dir),recursive = TRUE)[grep('*point02.txt$',
    list.files((track_dir),recursive = TRUE))])))  
}
```

```{r}
landmarks  =  read.delim(normalizePath(paste0(track_dir,'/',file_tbl$landmark[1])),
                          sep = "\t", header  =  FALSE)[,1:3]
names(landmarks) <- c("frame","x","y")

if (length(landmarks$x) %% 2 == 1) {warning("Odd number of landmarks!") }
num_trials  =  length(landmarks$x)/2 
```

```{r}
animal_track  =  read.delim(normalizePath(paste0(track_dir,'/',file_tbl$track[1])),
                          sep = "\t", header = FALSE)[,1:3]
names(animal_track) <- c("frame","x","y")
```

### Trial Limits

```{r}
trial_limits <- get_trial_limits(landmarks,animal_track,file_tbl,1)
trial_limits
```

### Get Tracked Object Position

```{r}
trial_track_list <- get_tracked_object_pos(trial_limits, animal_track,
                                           circ0  =  .1,circ1  =  .2)
trackz           <- trial_track_list[[1]]
tail(trackz[[1]])
```

```{r}
trial_limits      <- trial_track_list[[2]]
tail(trial_limits)
```

```{r}
radiate(trackz[[1]], ncols  =  NULL, circ1  =  NULL, circ2  =  NULL, 
        group1  =  NULL, group2  =  NULL, ticks  =  NULL,
  degrees  =  NULL,legend  =  NULL,
  title  =  NULL, xlab  =  NULL,ylab  =  NULL,axes  =  NULL)
```

```{r}
trackz_n_limits <- get_all_object_pos(trial_limits, animal_track, file_tbl, track_dir)
all_tracks_df       <- trackz_n_limits[[1]]
tail(all_tracks_df)
```                            


```{r}
trialz <- trackz_n_limits[[2]]
tail(trialz)  
```

Below can be left out for a wee bit. **This can be moved into the get_all_obj_pos functon**. 
This has stopped working to remove those trials - that's OK as identifying them is more important.

```{r}
# idx <- which(trialz$x0 == trialz$x1 & trialz$y0 == trialz$y1)
# if (length(idx) > 0) {warning(paste("Trials", idx, "have errors!"))}
# #all_trackz[idx] <- NULL
# ##### LEAVE OUT FOR MOMENT!
# #trialz <- trialz[-c(idx),] 
# ## something wrong with this line!
# print(paste(length(all_trackz),"tracks post culling"))
# print(paste(dim(trialz)[1],"trials in limits list post culling"))
```

```{r}
radiate(all_tracks_df, ncols  =  NULL, circ1  =  NULL, circ2  =  NULL, 
        group1  =  NULL, group2  =  trial_num, ticks  =  NULL,
  degrees  =  NULL,legend  =  NULL,
  title  =  NULL, xlab  =  NULL,ylab  =  NULL,axes  =  NULL)
```

