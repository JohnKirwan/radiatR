---
title: "Camera Calibration Workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Camera Calibration Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
library(radiatR)
```

This vignette walks through the end-to-end camera calibration utilities available in **radiatR**. The goal is to show how to turn raw pixel coordinates into a metric representation that removes lens distortion and accounts for camera intrinsics, matching the pinhole model implemented in packages such as MATLAB's *Computer Vision Toolbox*.

## Required calibration parameters

The calibration helpers expect three key ingredients:

1. **Intrinsic matrix (`K`)** – a 3 × 3 matrix in the usual form
   $\left[\begin{smallmatrix}f_x & 0 & c_x \ 0 & f_y & c_y \ 0 & 0 & 1\end{smallmatrix}\right]$ where `c_x` / `c_y` are the principal point in pixels and `f_x` / `f_y` are the focal lengths, also in pixels.
2. **Distortion coefficients (`k`)** – passed as either a numeric vector, a named vector (e.g., `c(k1 = ..., k2 = ..., p1 = ..., p2 = ...)`), or a list with `radial` / `tangential` entries. Missing coefficients are assumed to be zero.
3. **Metric focal length (`F`)** – the physical focal length (or scaling factor) in millimetres. Supply a scalar for isotropic scaling or a length-2 vector to differentiate between axes.

You can bundle these into a [`CalModel`](../reference/CalModel-class.html) object for repeated use with trajectory sets.

```{r cal-model}
K <- matrix(c(800,   0, 640,
                0, 800, 360,
                0,   0,   1),
            nrow = 3, byrow = TRUE)
distortion <- c(k1 = -0.28, k2 = 0.05, p1 = 1e-3, p2 = -5e-4)
F_mm <- 20

cal_model <- new("CalModel", K = K, k = distortion, F = rep(F_mm, 2))
cal_model
```


## Checkerboard control points

When calibrating from a checkerboard sequence you often need the world coordinates for the inner corners. The helper `checkerboard_points()` mirrors MATLAB's `generateCheckerboardPoints` so you can generate them directly in **radiatR**.

```{r checkerboard}
cb_pts <- checkerboard_points(c(9, 7), square_size = 5)
head(cb_pts)
```

Use the `square_size` argument to match your physical square width (in millimetres, centimetres, etc.) and pass `as_tibble = FALSE` if you prefer a simple matrix of x/y coordinates.

## Calibrating single points

Use `cam_cal_pt()` when you need to correct a single pixel coordinate, for example when transforming landmarks exported from a digitising tool.

```{r single-point}
raw_pt <- c(x = 650, y = 380)
cam_cal_pt(raw_pt["x"], raw_pt["y"], K, distortion, F_mm)
```

Internally the function:

1. Recentres the point by subtracting the principal point (`optically_center()`),
2. Normalises by the focal lengths (`focalize()`),
3. Removes radial and tangential distortion via a fixed-point iteration (`radial_distort()`),
4. Converts the undistorted coordinates into millimetres (`scaled_xy2mm()`).

Both the iteration count and convergence tolerance are configurable via the `max_iterations` and `tolerance` arguments.

## Interactive collection

For small calibration sets you can grab corners manually. `calibration_session()` opens a graphics device per frame and records clicks in row-major order, then solves a planar calibration:

```{r interactive, eval = FALSE}
frames <- list('frame1.png', 'frame2.png')
calib <- calibration_session(frames, pattern = 'chessboard', board_dims = c(9, 7), square_size = 5)
calib$intrinsics
```

The helper works with chessboard, ChArUco, or AprilTag grids—simply provide `board_dims`/`square_size` matching the pattern. The output contains the `CalModel`, per-frame extrinsics, and reprojection errors so you can inspect the fit.

## Batch calibration

For tables or matrices of points, `cam_cal_many()` processes everything in one pass.

```{r batch-cal}
pts <- matrix(
  c(640, 360,
    700, 420,
    580, 320),
  ncol = 2,
  byrow = TRUE,
  dimnames = list(NULL, c("x", "y"))
)
cam_cal_many(pts, K, distortion, F_mm)
```

Supplying a `CalModel` lets you calibrate entire trajectory sets with a single call.

```{r trajset-example}
# Simulate three simple trajectories in pixel space
set.seed(1)
traj_px <- data.frame(
  id = rep(c("A", "B", "C"), each = 10),
  frame = rep(seq_len(10), times = 3),
  x = runif(30, 600, 700),
  y = runif(30, 300, 420)
)
ts_px <- TrajSet(traj_px, id = "id", time = "frame", x = "x", y = "y", angle = "frame", normalize_xy = FALSE)

ts_mm <- calibrate_positions(ts_px, cal_model)
head(as.data.frame(ts_mm))
```

## Persisting correspondences

You can stash the clicked points for later reuse. The helpers below write a CSV and rebuild the calibration without reopening the graphics device.

```{r persist-points, eval = FALSE}
points_tbl <- calibration_points_tibble(calib$image_points)
write_calibration_points(calib$image_points, "calibration-points.csv")
replay <- calibration_from_points(board_dims = c(9, 7), square_size = 5,
                                  image_points = points_tbl, quiet = TRUE)
replay$intrinsics
```

```{r apply-transform, eval = FALSE}
ts_px_cal <- calib$transform(ts_px)
head(as.data.frame(ts_px_cal))
```

`calibrate_positions()` updates the `x`/`y` columns in-place and re-computes `angle` so that the values reflect the corrected metric geometry.

## Convergence diagnostics

The undistortion step uses a fixed-point solver similar to the `undistortPoints` routine in OpenCV. The defaults (`max_iterations = 5`, `tolerance = 1e-9`) are usually sufficient. If the distortion model is extreme or the points are far from the optical axis, you can relax these parameters:

```{r convergence, eval = FALSE}
cam_cal_pt(650, 380, K, distortion, F_mm, max_iterations = 10, tolerance = 1e-12)
```

If convergence fails, the function returns the last iterate; consider checking your coefficients or tightening the stopping criteria.

## Summary

- Use `cam_cal_pt()` / `cam_cal_many()` for one-off points and tables.
- Wrap parameters in a `CalModel` to correct every trajectory in a `TrajSet` via `calibrate_positions()`.
- Distortion coefficients can be radial-only or include tangential terms; unnamed coefficients fall back to a sensible ordering.

These helpers should provide a drop-in path for applying calibration results from common toolboxes and maintainers of large tracking datasets.
